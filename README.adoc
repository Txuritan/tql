= TQL

Compile-time ORM, inspired by Django ORM, written in Rust.
Tql is implemented as a procedural macro and even works on the stable version of Rust (https://github.com/antoyo/tql/tree/master/examples/todo-stable[look at this example to see how to use tql on stable]).

*This library is in alpha stage: it has not been thoroughly tested and its API may change at any time.*

image:https://img.shields.io/travis/antoyo/relm/master.svg[link="https://travis-ci.org/antoyo/relm"]
image:https://img.shields.io/crates/l/relm.svg[link="LICENSE"]

== Requirements

Currently, `tql` only supports the `PostgreSQL` database (more databases will be supported in the future).
So, you need to install `PostgreSQL` in order to use this crate.

== Usage

First, add this to you `Cargo.toml`:

[source,toml]
----
[dependencies]
chrono = "^0.4.0"
tql = { git = "https://github.com/antoyo/tql" }
tql_macros = { git = "https://github.com/antoyo/tql" }

[dependencies.postgres]
features = ["with-chrono"]
version = "^0.15.1"
----

(You can remove the `chrono` stuff if you don't want to use the date and time types in your model.)

Next, add this to your crate:

[source,rust]
----
#![feature(proc_macro)]

extern crate chrono;
extern crate postgres;
extern crate tql;
#[macro_use]
extern crate tql_macros;

use postgres::{Connection, TlsMode};
use tql::PrimaryKey;
use tql_macros::sql;
----

:source-highlighter: pygments

[cols="1a,1a", options="header"]
|===
| SQL
| Rust

|
[source, sql]
----
SELECT * FROM Table
----
|
[source, rust]
----
Table.all()
----

|
[source, sql]
----
SELECT * FROM Table WHERE field1 = 'value1'
----
|
[source, rust]
----
Table.filter(field1 == "value1")
----

|
[source, sql]
----
SELECT * FROM Table WHERE primary_key = 42
----
|
[source, rust]
----
Table.get(42)

// Shortcut for:

Table.filter(primary_key == 42)[0..1];
----

|
[source, sql]
----
SELECT * FROM Table WHERE field1 = 'value1'
----
|
[source, rust]
----
Table.get(field1 == "value1")

// Shortcut for:

Table.filter(field1 == "value1")[0..1];
----

|
[source, sql]
----
SELECT * FROM Table WHERE field1 = 'value1' AND field2 < 100
----
|
[source, rust]
----
Table.filter(field1 == "value1" && field2 < 100)
----

|
[source, sql]
----
SELECT * FROM Table WHERE field1 = 'value1' OR field2 < 100
----
|
[source, rust]
----
Table.filter(field1 == "value1" \|\| field2 < 100)
----

|
[source, sql]
----
SELECT * FROM Table ORDER BY field1
----
|
[source, rust]
----
Table.sort(field1)
----

|
[source, sql]
----
SELECT * FROM Table ORDER BY field1 DESC
----
|
[source, rust]
----
Table.sort(-field1)
----

|
[source, sql]
----
SELECT * FROM Table LIMIT 0, 20
----
|
[source, rust]
----
Table[0..20]
----

|
[source, sql]
----
SELECT * FROM Table
WHERE field1 = 'value1'
  AND field2 < 100
ORDER BY field2 DESC
LIMIT 10, 20
----
|
[source, rust]
----
Table.filter(field1 == "value1" && field2 < 100)
    .sort(-field2)[10..20]
----

|
[source, sql]
----
INSERT INTO Table(field1, field2) VALUES('value1', 55)
----
|
[source, rust]
----
Table.insert(field1 = "value1", field2 = 55)
----

|
[source, sql]
----
UPDATE Table SET field1 = 'value1', field2 = 55 WHERE id = 1
----
|
[source, rust]
----
Table.get(1).update(field1 = "value1", field2 = 55);

// or

Table.filter(id == 1).update(field1 = "value1", field2 = 55);
----

|
[source, sql]
----
DELETE FROM Table WHERE id = 1
----
|
[source, rust]
----
Table.get(1).delete();

// ou

Table.filter(id == 1).delete()
----

|
[source, sql]
----
SELECT AVG(field2) FROM Table
----
|
[source, rust]
----
Table.aggregate(avg(field2))
----

|
[source, sql]
----
SELECT AVG(field1) FROM Table1 GROUP BY field2
----
|
[source, rust]
----
Table1.values(field2).annotate(avg(field1))
----

|
[source, sql]
----
SELECT AVG(field1) as average FROM Table1
GROUP BY field2
HAVING average > 5
----
|
[source, rust]
----
Table1.values(field2).annotate(average = avg(field1))
    .filter(average > 5)
----

|
[source, sql]
----
SELECT AVG(field1) as average FROM Table1
WHERE field1 < 10
GROUP BY field2
HAVING average > 5
----
|
[source, rust]
----
Table1.filter(field1 < 10).values(field2)
    .annotate(average = avg(field1)).filter(average > 5)
----

|
[source, sql]
----
SELECT Table1.field1, Table2.field1 FROM Table1
INNER JOIN Table2 ON Table1.pk = Table2.fk
----
|
[source, rust]
----
#[derive(SqlTable)]
struct Table1 {
    pk: PrimaryKey,
    field1: i32,
}

#[derive(SqlTable)]
struct Table2 {
    field1: i32,
    fk: ForeignKey<Table1>,
}

Table1.all().join(Table2)
----

|
[source, sql]
----
SELECT * FROM Table1 WHERE YEAR(date) = 2015
----
|
[source, rust]
----
Table1.filter(date.year() == 2015)
----

|
[source, sql]
----
SELECT * FROM Table1 WHERE INSTR(field1, 'string') > 0
----
|
[source, rust]
----
Table1.filter(field1.contains("string"))
----

|
[source, sql]
----
SELECT * FROM Table1 WHERE field1 LIKE 'string%'
----
|
[source, rust]
----
Table1.filter(field1.starts_with("string"))
----

|
[source, sql]
----
SELECT * FROM Table1 WHERE field1 LIKE '%string'
----
|
[source, rust]
----
Table1.filter(field1.ends_with("string"))
----

|
[source, sql]
----
SELECT * FROM Table1 WHERE field1 IS NULL
----
|
[source, rust]
----
Table1.filter(field1.is_none())
----

|
[source, sql]
----
SELECT * FROM Table1 WHERE field1 REGEXP BINARY '\^[a-d]'
----
|
[source, rust]
----
Table1.filter(field1.regex(r"\^[a-d]"))
----

|
[source, sql]
----
SELECT * FROM Table1 WHERE field1 REGEXP '\^[a-d]'
----
|
[source, rust]
----
Table1.filter(field1.iregex(r"\^[a-d]"))
----

|
[source, sql]
----
CREATE TABLE IF NOT EXISTS Table1 (
    pk INTEGER NOT NULL AUTO_INCREMENT,
    field1 INTEGER,
    PRIMARY KEY (pk)
)
----
|
[source, rust]
----
#[derive(SqlTable)]
struct Table1 {
    pk: PrimaryKey,
    field1: i32,
}

Table1.create()
----
